#include <math_constants>

parameter int size = 500 : range(10, 1000);
parameter float light_latitude  = 0 : range(0., PI/2.);
parameter float light_longitude = 0 : range(0, TAU);
parameter vec3 diff_color  = vec3(.8, .2, .1);
parameter vec3 back_color  = vec3( 0,  0, .1) : hidden();
parameter vec3 spec_color  = vec3(.2, .2, .2);
parameter float shininess  = 10 : range(-10, 100);

parameter float gamma = 2.2 : range(1, 3);

parameter float diff_amplification = 10 : range(1, 100);

image reference = file("sphere.png") : full_range();

glsl vec3 light_dir() {
return vec3(
    cos(light_latitude)*sin(light_longitude),
    sin(light_latitude),
    cos(light_latitude)*cos(light_longitude)
    );
}

glsl vec3 angles(vec2 position){
    // nx and ny between -1 and 1, nz just follows trigonometry
    vec2 nxny = 2 * position - 1;
	// TODO verify this is correct
	if (length(nxny)>1){
		return vec3(0, 0, -1);
	}
	nxny = normalize(nxny) * 4 * asin(length(nxny)) / TAU;
	// works without abs usually, but not on my workstation
    float nz  = sqrt(1 - pow(abs(nxny.x), 2) - pow(abs(nxny.y), 2));
    return vec3(nxny, nz);
}

image sphere_normal = glsl(angles, vec2(500, 500));

glsl vec3 lambert(vec2 position){
    // Light source direction
    vec3 l = normalize(light_dir());
    // normal of material
    vec3 n = normalize(angles(position));
	if (n.b<0){
		return back_color;
	}
    float diff_light = max(0, dot(l, n));
	vec3 color = diff_color*diff_light;
    return pow(color, vec3(gamma));
}

// image sphere_lambertian = glsl(lambert, vec2(size, size));

glsl vec3 lambert_phong(vec2 position){
    // Light source direction
    vec3 l = normalize(light_dir());
    // normal of material
    vec3 n = normalize(angles(position));
	if (n.b<0){
		return back_color;
	}
    // Direction of a perfectly reflected ray
    vec3 r = 2 * n * dot(l, n) - l;
    // Direction toward the viewer
    vec3 v = vec3(0,0,1);

    float diff_light = max(0, dot(l, n));

    vec3 spec = spec_color * pow(max(0, dot(r, v)), shininess);

    vec3 color = diff_color * diff_light + spec ;
    return pow(color, vec3(1./gamma));
}

image sphere_lambert_phong = glsl(lambert_phong, vec2(size, size)) : full_range();

glsl vec3 differences_pos(vec2 position){
	return diff_amplification * max(vec3(0), texture(sphere_lambert_phong, position).rgb - texture(reference, position).rgb);
}
glsl vec3 differences_neg(vec2 position){
	return diff_amplification * max(vec3(0), texture(reference, position).rgb - texture(sphere_lambert_phong, position).rgb);
}

image comp_pos = glsl(differences_pos, vec2(size, size));
image comp_neg = glsl(differences_neg, vec2(size, size));
